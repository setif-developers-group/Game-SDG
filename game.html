<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Adventure</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-color: #1a1a2e;
            --primary-color: #e94560;
            --secondary-color: #537fe7;
            --text-color: #e8e8e8;
            --wall-color: #2e2e42;
            --path-color: #3b3b54;
            --player-color: #ffbe0b;
            --enemy-color: #ff5959;
            --item-color: #4cd137;
        }

        body {
            font-family: 'Cairo', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            position: relative;
        }

        /* Moving background effect */
        .background-dots {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(26, 26, 46, 0.5), rgba(26, 26, 46, 0.5)), repeating-linear-gradient(45deg, #1f1f3a, #1f1f3a 5px, transparent 5px, transparent 10px);
            background-size: 20px 20px;
            animation: moveBackground 60s linear infinite;
        }

        @keyframes moveBackground {
            from { background-position: 0 0; }
            to { background-position: 200px 200px; }
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-in-out;
            opacity: 0;
            visibility: hidden;
            z-index: 10;
        }

        .screen.active {
            opacity: 1;
            visibility: visible;
        }

        /* --- Main Menu --- */
        #main-menu {
            font-family: 'Orbitron', sans-serif;
        }

        #main-menu h1 {
            font-size: 3em;
            color: var(--player-color);
            text-shadow: 0 0 15px var(--player-color);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 80%;
            max-width: 300px;
            margin-top: 40px;
        }

        .menu-button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .menu-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        /* --- Game Screen --- */
        #game-screen {
            justify-content: flex-start;
            padding-top: 20px;
        }

        .game-info-mobile {
            display: flex;
            justify-content: space-between;
            width: 90%;
            max-width: 600px;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #game-canvas {
            border: 5px solid var(--wall-color);
            border-radius: 10px;
            background-color: var(--path-color);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            margin-top: 10px;
        }

        .mobile-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            width: 100%;
            max-width: 300px;
            margin-top: 20px;
            padding: 10px;
            gap: 10px;
        }

        .control-button {
            grid-area: var(--dir);
            background-color: rgba(74, 144, 226, 0.7);
            color: white;
            border: none;
            padding: 20px;
            font-size: 2em;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s;
            touch-action: manipulation;
        }

        #up-button { --dir: up; }
        #down-button { --dir: down; }
        #left-button { --dir: left; }
        #right-button { --dir: right; }

        .control-button:active {
            transform: scale(0.9);
            background-color: var(--primary-color);
        }

        /* --- Pop-up Messages --- */
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 30, 30, 0.95);
            color: white;
            padding: 30px 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s ease-in-out;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        .message-box.show {
            opacity: 1;
            visibility: visible;
        }
        
        .message-box button {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .message-box button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        #victory-message h2, #gameover-message h2 {
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px white;
        }

        #victory-message button, #gameover-message button {
            background: var(--primary-color);
        }
        
        #level-complete-message h2 {
            color: var(--secondary-color);
            font-family: 'Orbitron', sans-serif;
        }

        /* Health Bar */
        .health-bar-container {
            width: 100%;
            height: 10px;
            background-color: #383838;
            border-radius: 5px;
            overflow: hidden;
        }
        .health-bar {
            width: 100%;
            height: 100%;
            background-color: var(--player-color);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>

    <div class="background-dots"></div>

    <!-- Main Menu Screen -->
    <div id="main-menu" class="screen active">
        <h1>Maze Adventure</h1>
        <div class="menu-buttons">
            <button class="menu-button" onclick="showScreen('game-screen')">Start Game</button>
            <button class="menu-button">Settings</button>
            <button class="menu-button">Levels</button>
            <button class="menu-button">Help</button>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="screen">
        <div class="game-info-mobile">
            <div>Score: <span id="score-value">0</span></div>
            <div>Level: <span id="level-value">1</span></div>
        </div>
        <div class="health-bar-container">
            <div id="health-bar" class="health-bar"></div>
        </div>
        <canvas id="game-canvas"></canvas>
        <div class="mobile-controls">
            <button id="up-button" class="control-button">▲</button>
            <button id="left-button" class="control-button">◀</button>
            <button id="right-button" class="control-button">▶</button>
            <button id="down-button" class="control-button">▼</button>
        </div>
    </div>

    <!-- Level Complete Message -->
    <div id="level-complete-message" class="message-box">
        <h2>Level Complete!</h2>
        <p id="level-complete-score"></p>
        <button id="next-level-button">Next Level</button>
    </div>

    <!-- Game Over Message -->
    <div id="gameover-message" class="message-box">
        <h2>Game Over</h2>
        <p>Your journey has ended.</p>
        <button onclick="window.location.reload()">Restart</button>
    </div>

    <!-- Victory Message -->
    <div id="victory-message" class="message-box">
        <h2>Congratulations!</h2>
        <p>You have completed the entire maze!</p>
        <button onclick="window.location.reload()">Play Again</button>
    </div>

    <script>
        // Game settings
        const GRID_WIDTH = 15;
        const GRID_HEIGHT = 15;
        let TILE_SIZE;

        // Game variables
        let canvas, ctx;
        let player, enemies, items;
        let health = 100;
        let score = 0;
        let level = 1;
        let gameRunning = false;
        let touchControls = false;

        const healthBar = document.getElementById('health-bar');

        // Level maps (0=path, 1=wall, 4=item)
        const levels = [
            // Level 1
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            // Level 2 (harder)
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ]
        ];

        let currentMap;
        let enemyInterval;

        const soundManager = {
            collect: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3'),
            hit: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3'),
            win: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3'),
            play: function(sound) {
                // To avoid CORS issues, we can just log the action
                console.log(`Playing sound: ${sound}`);
            }
        };

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            if (screenId === 'game-screen') {
                startGame();
            }
        }
        
        // Player
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = TILE_SIZE * 0.7;
            }
            draw() {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player-color');
                ctx.beginPath();
                ctx.arc(this.x * TILE_SIZE + TILE_SIZE / 2, this.y * TILE_SIZE + TILE_SIZE / 2, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
            move(dx, dy) {
                if (!gameRunning) return;
                let newX = this.x + dx;
                let newY = this.y + dy;
                if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT && currentMap[newY][newX] !== 1) {
                    this.x = newX;
                    this.y = newY;
                    checkCollisions();
                    draw();
                }
            }
        }
        
        // Enemy
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = TILE_SIZE * 0.7;
            }
            draw() {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--enemy-color');
                ctx.beginPath();
                ctx.moveTo(this.x * TILE_SIZE + TILE_SIZE / 2, this.y * TILE_SIZE + TILE_SIZE / 2 - this.size / 2);
                ctx.lineTo(this.x * TILE_SIZE + TILE_SIZE / 2 + this.size / 2, this.y * TILE_SIZE + TILE_SIZE / 2 + this.size / 2);
                ctx.lineTo(this.x * TILE_SIZE + TILE_SIZE / 2 - this.size / 2, this.y * TILE_SIZE + TILE_SIZE / 2 + this.size / 2);
                ctx.closePath();
                ctx.fill();
            }
            move() {
                let dx = 0, dy = 0;
                if (player.x > this.x && currentMap[this.y][this.x + 1] !== 1) dx = 1;
                else if (player.x < this.x && currentMap[this.y][this.x - 1] !== 1) dx = -1;
                else if (player.y > this.y && currentMap[this.y + 1][this.x] !== 1) dy = 1;
                else if (player.y < this.y && currentMap[this.y - 1][this.x] !== 1) dy = -1;

                if (dx !== 0 && currentMap[this.y][this.x + dx] !== 1) {
                    this.x += dx;
                } else if (dy !== 0 && currentMap[this.y + dy][this.x] !== 1) {
                    this.y += dy;
                }
            }
        }
        
        // Item
        class Item {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = TILE_SIZE * 0.5;
            }
            draw() {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--item-color');
                ctx.beginPath();
                ctx.arc(this.x * TILE_SIZE + TILE_SIZE / 2, this.y * TILE_SIZE + TILE_SIZE / 2, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function init() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');

            // Set canvas size based on window size
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
            
            // Setup button event listeners
            document.getElementById('up-button').addEventListener('click', () => player.move(0, -1));
            document.getElementById('down-button').addEventListener('click', () => player.move(0, 1));
            document.getElementById('left-button').addEventListener('click', () => player.move(-1, 0));
            document.getElementById('right-button').addEventListener('click', () => player.move(1, 0));
            document.getElementById('next-level-button').addEventListener('click', () => {
                document.getElementById('level-complete-message').classList.remove('show');
                loadLevel(level);
            });
            
            // Check for touch device to show controls
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.querySelector('.mobile-controls').style.display = 'grid';
                touchControls = true;
            }
        }

        function setCanvasSize() {
            // Determine the smaller of the two dimensions (width or height)
            const minDimension = Math.min(window.innerWidth, window.innerHeight);
            // Calculate a tile size that fits the grid perfectly
            TILE_SIZE = Math.floor((minDimension * 0.8) / GRID_WIDTH);
            canvas.width = GRID_WIDTH * TILE_SIZE;
            canvas.height = GRID_HEIGHT * TILE_SIZE;
            if (gameRunning) {
                draw();
            }
        }
        
        function startGame() {
            gameRunning = true;
            health = 100;
            score = 0;
            level = 1;
            updateInfo();
            loadLevel(level);
            
            clearInterval(enemyInterval);
            enemyInterval = setInterval(() => {
                if (gameRunning) {
                    enemies.forEach(enemy => enemy.move());
                    checkCollisions();
                    draw();
                }
            }, 500);
        }
        
        function loadLevel(lvl) {
            currentMap = JSON.parse(JSON.stringify(levels[lvl - 1]));
            player = new Player(1, 1);
            enemies = [];
            items = [];
        
            let enemiesToAdd = Math.floor(lvl * 1.5);
            for(let i = 0; i < enemiesToAdd; i++) {
                 let x, y;
                 do {
                     x = Math.floor(Math.random() * GRID_WIDTH);
                     y = Math.floor(Math.random() * GRID_HEIGHT);
                 } while(currentMap[y][x] === 1 || (x === player.x && y === player.y));
                 enemies.push(new Enemy(x, y));
            }
        
            let itemsToAdd = Math.floor(lvl * 1.2);
            for(let i = 0; i < itemsToAdd; i++) {
                 let x, y;
                 do {
                     x = Math.floor(Math.random() * GRID_WIDTH);
                     y = Math.floor(Math.random() * GRID_HEIGHT);
                 } while(currentMap[y][x] === 1 || (x === player.x && y === player.y) || (enemies.some(e => e.x === x && e.y === y)));
                 items.push(new Item(x, y));
            }
            draw();
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (currentMap[y][x] === 1) {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall-color');
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        
            items.forEach(item => item.draw());
            enemies.forEach(enemy => enemy.draw());
            player.draw();
        }
        
        function checkCollisions() {
            enemies.forEach((enemy) => {
                if (player.x === enemy.x && player.y === enemy.y) {
                    health -= 10;
                    updateInfo();
                    soundManager.play('hit');
                    if (health <= 0) {
                        gameOver();
                    }
                }
            });
        
            let itemIndex = items.findIndex(item => player.x === item.x && player.y === item.y);
            if(itemIndex !== -1) {
                score += 10;
                items.splice(itemIndex, 1);
                updateInfo();
                soundManager.play('collect');
            }
        
            if (items.length === 0) {
                nextLevel();
            }
        }
        
        function updateInfo() {
            document.getElementById('score-value').innerText = score;
            document.getElementById('level-value').innerText = level;
            healthBar.style.width = `${health}%`;
        }
        
        function nextLevel() {
            gameRunning = false;
            clearInterval(enemyInterval);
            
            level++;
            if (level > levels.length) {
                document.getElementById('victory-message').classList.add('show');
                soundManager.play('win');
            } else {
                document.getElementById('level-complete-score').innerText = `Score: ${score}`;
                document.getElementById('level-complete-message').classList.add('show');
            }
        }
        
        function gameOver() {
            gameRunning = false;
            clearInterval(enemyInterval);
            document.getElementById('gameover-message').classList.add('show');
            soundManager.play('hit');
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || touchControls) return;
            switch(e.key) {
                case 'ArrowUp': case 'w': player.move(0, -1); break;
                case 'ArrowDown': case 's': player.move(0, 1); break;
                case 'ArrowLeft': case 'a': player.move(-1, 0); break;
                case 'ArrowRight': case 'd': player.move(1, 0); break;
            }
        });
        
        window.onload = init;
    </script>
</body>
</html>
